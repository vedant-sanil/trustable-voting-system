# Voting Server API

## Overview

This API specifies all types of messages that a server node shall handle.


The types of messages include the following.

------

## GetServerStatus

**Description**: Check if the server node has been set up properly. This message only has a single response, and responds with a successful return code if the server is functioning properly.

**Note:** You can use this API call for debugging purposes, to check if your server has crashed at any point in the client voting process!

### request


**URL**: `/checkserver`

**Method**: `POST`

**Body**: not specified

### response_1

**Status** : `200 OK`

**Body** :

```json
{
    "success": true,
    "info": ""
}
```
`success`: a boolean true, denotes that server is running properly

`info`: a string, not specified

File: message/StatusReply.java

------

## BecomeCandidate

**Description**: Add a normal client to the list of candidates competing in the election.

> An incoming `becomecandidate` request fails under the following conditions:
- If the requestor has not added their public key to the public key blockchain.
- If the requestor is a candidate already.

### request

**URL**: `/becomecandidate`

**Method**: `POST`


**Body**:
```json
{
    "user_name": "node_1"
}
```

`user_name`: username of the node trying to become a candidate.

File: message/BecomeCandidateRequest.java


### response_1

**Description**: On success.


**Code** : `200 OK`

**Body** :

```json
{
    "success": true,
    "info": ""
}
```
`success`: a boolean true, denotes that the requesting node became a candidate successfully.

`info`: a string, not specified.

File: message/StatusReply.java

### response_2

**Code** : `422 Unprocessable Entity`

**Content** :

```json
{
    "success": false,
    "info": "CandidatePublicKeyUnknown"
}
```

`success`: a boolean false.

`info`: a string, error information

File: message/StatusReply.java


### response_3

**Code** : `409 Conflict`

**Content** :
```json
{
    "success": false,
    "info": "NodeAlreadyCandidate"
}
```

`success`: a boolean false.

`info`: a string, error information

File: message/StatusReply.java

------

## GetCandidates

**Description**: Get the list of candidates contesting in the election.

### request

**URL**: `/getcandidates`

**Method**: `POST`

**Body**: not specified


### response_1

**Status** : `200 OK`

**Body** :

```json
{
    "candidates": [
        "candidate_name_1",
        "candidate_name_2"
    ]
}
```

*candidates*: An array of the candidate names. The names are not guaranteed to be in any particular order.  

File: message/GetCandidatesReply.java


------

## CastVote

**Description**: Cast a vote for a candidate.

> A vote that any node casts must be in encrypted format, so that no malicious interceptor is able to modify the vote, or pretend to be a voter.

> Any client node can cast a vote for any candidate contesting in the election. `castvote` can fail for the following reasons:
- Peer tries to vote multiple times in the same election cycle.
- Peer tries to vote for a non-candidate.

### request

**URL**: `/castvote`

**Method**: `POST`

**Body**:
```json
{
    "encrypted_vote_contents": "xxx",
    "encrypted_session_key": "yyy"
}
```

> **Session Key:**
All voting clients must generate an 128-bit AES session key. This session-key is used to encrypt the actual contents of the vote message sent by the voter.
AES is a symmetric key encryption scheme, and is generally faster than asymmetric key encryption (like RSA).

`encrypted_session_key` ('yyy' in the json object structure given above): The encrypted session key generated by the client before casting the vote. To protect the AES session key, it is encrypted using the public key of the server.

To put it simply:

***encrypted_session_key*** = **Enc** (128_bit_AES_Session_Key) <sub>S_Pub_Key</sub>


`encrypted_vote_contents` ("xxx" in the json object structure given above): The encrypted vote cast by the voter. This encryption was performed using the session key generated by the client.

You are allowed to follow one of the following two methods to create `encrypted_vote_contents`:

----

***Method 1 (Authentication using digital signatures):***

Contents of `encrypted_vote_contents`:

```json
{
    "chain_id": 2,
    "user_name": "voter_1",
    "voted_for": "candidate_1",
    "signature": "zzz"
} EncryptedBy(AES_Session_Key)
```

`chain_id`: The chain to which the vote is to be added. This field always corresponds to the voting blockchain (Id: 2)

`user_name`: The username of the voter casting the vote.

`voted_for`: The candidate for whom the vote is being cast.

`signature` ("zzz" in the json object structure given above): This field is an encrypted hash of the "chain_id", "user_name" and "voted_for" fields. Some popular digital signature schemes included (but not limited to) SHA1withRSA, MD5withDSA etc.

***Note:***
- On the client's side, before sending the vote to the server, the signature is created using the private key of the voter.
- On the server's side, the signature is verified using the public key of the voter.

***Important:***  If you choose to follow this method of authentication, you must ensure that:
- When the server receives the vote, it recalculates and verifies the digital signature hash using the "chain_id", "user_name" and "voted_for" fields. The server must add the vote to the voting blockchain only if the signature is verified correctly. This check ensures the authenticity, integrity and non-repudiation of the message.
----

----

***Method 2 (Authentication by performing encryption using voter's private key):***


Contents of `encrypted_vote_contents`:

```json
{
    "chain_id": 2,
    "user_name": "voter_1",
    "encrypted_vote": "zzz"
} EncryptedBy(AES_Session_Key)
```

`chain_id`: The chain to which the vote is to be added. This field always corresponds to the voting blockchain (Id: 2)

`user_name`: The username of the voter casting the vote.

Contents of `encrypted_vote` ("zzz" in the json object structure given above):

```json
{
    "user_name": "voter_1",
    "voted_for": "candidate_1"
} EncryptedBy(V_Priv_key)
```

`user_name`: The username of the voter casting the vote.

`voted_for`: The candidate for whom the vote is being cast.

----


Glossary for the above section:

`S_Pub_Key`: Server's public key

`AES_Session_Key`: 128-bit AES Session Key for symmetric encryption

`V_Priv_key`: Voter's private key

File: message/CastVoteRequest.java


### response_1

**Status** : `200 OK`

**Body** :
```json
{
    "success": true,
    "info": ""
}
```

`success`: a boolean true, denotes that the vote was cast successfully, and the vote was added to the voting blockchain. `false` denotes that the vote cast did not have the right parameters/was not encrypted properly.

`info`: a string, not specified

File: message/StatusReply.java

### response_2

**Code** : `422 Unprocessable Entity`

**Content** :

```json
{
   "success": false,
   "info": "InvalidCandidate"
}
```

`success`: a boolean false.

`info`: a string, error information

File: message/StatusReply.java

### response_3

**Code** : `409 Conflict`

**Content** :

```json
{
   "success": false,
   "info": "DuplicateVote"
}
```

`success`: a boolean false.

`info`: a string, error information

File: message/StatusReply.java

------

## CountVotes

**Description**: Count the votes per candidate.

### request

**URL**: `/countvotes`

**Method**: `POST`

**Body**:
```json
{
    "return_votes_for": "candidate_1"
}
```

`return_votes_for`: The candidate for which vote count is to be returned.

File: message/CountVotesRequest.java

### response_1

**Status** : `200 OK`

**Body** :

```json
{
    "success": true,
    "vote_count": 10
}
```
*success*: Denotes that server is running properly.

*vote_count*: Number of votes received by `return_votes_for`

File: message/CountVotesReply.java


### response_2

**Status** : `422 Unprocessable Entity`

**Body** :

```json
{
   "success": false,
   "info": "InvalidCandidate"
}
```

`success`: a boolean false.

`info`: a string, error information

File: message/StatusReply.java
